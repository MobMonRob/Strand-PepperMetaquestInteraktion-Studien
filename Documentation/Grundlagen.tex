\chapter{Grundlagen}\label{chap:Grundlagen}
Im folgenden werden die benötigten technischen Grundlagen beschrieben und genauer beleuchtet.

\section{Publish and Subscribe}\label{sec:PublishAndSubscribe}
Bevor wir uns mit den Technologien und Herangehensweisen des Pepper Roboters beziehungsweise dessen Betriebssystem beschäftigen, müssen wir uns mit dem Publish-Subscribe-Modell auseinandersetzen.
\\

\noindent
Das Publish-Subscribe-Modell ist ein Paradigma für einen effektiven Nachrichtenaustausch in verteilten Systemen. Erstmals publiziert in einem Paper der \ac{ACM} von 1987\cite{wiki_publish_subscribe_pattern}, ermöglicht es die flexible Kommunikation zwischen verschiedenen Komponenten, indem es einen Mechanismus bereitstellt, über den Nachrichten von einem Sender, dem Publisher, an einen oder mehrere Empfänger, den Subscribern, verteilt werden können. Ein zentrales Element dieses Modells ist dabei Nachrichtenbroker oftmals auch nur als Borker referenziert, der als Vermittler zwischen Publishern und Subscribenden fungiert. Dieses Verhalten mit vielen Komponenten auf einige Topics, ist in \autoref{img:Publish-and-Subscribe} zur Veranschaulichung abgebildet.\\
\normfig{Publish-and-Subscribe}{0.8}{-}
\noindent
Der Broker empfängt Nachrichten vom Publisher und organisiert sie in verschiedene Kategorien, welche als Topics bezeichnet werden. Diese Topics dienen als thematische Selektionsmerkmale, die den Inhalt der Nachrichten beschreiben. Sie können in den verschiedensten Datentypen erfolgen, einfache Ganzzahlen, Texte bis hin zu Bildern oder weitaus komplexeren Datenstrukturen. Durch diese Kategorisierung in den Topics, wird eine gezielte Auswahl und Weiterleitung der Nachrichten ermöglicht.
\\

\noindent
Subscriber können bestimmte Topics abonnieren, die ihren Gewünschten entsprechen. Dadurch erhalten sie nur die Nachrichten, die zu den von ihnen gewählten Themen gehören. Dieser Prozess der Nachrichtenauswahl und -verarbeitung wird als Filterung bezeichnet und kann auf zwei Arten erfolgen: themenbasiert und inhaltsbasiert.
\\

\noindent
Im themenbasierten Ansatz erhalten Abonnenten alle Nachrichten zu den Topics, welche sie abonniert haben. Der Publisher definiert die verfügbaren Topics, aus welchen die Abonnenten selbst wählen können. Im inhaltsbasierten Ansatz dagegen, werden Nachrichten nur an die Abonnenten weitergeleitet, wenn sie den vom dessen festgelegten Kriterien entsprechen. Dabei ist der Abonnent für die Spezifikation dieser Kriterien verantwortlich\cite{itwissen_publish_subscribe_model}.
\\

\noindent
Das Publish-Subscribe-Modell bietetdurch seine Herangehensweise eine hohe Flexibilität und Skalierbarkeit, und wird daher in verschiedenen Anwendungsbereichen eingesetzt. Es ermöglicht eine Entkopplung von Nachrichtenerzeugung und -verarbeitung, was gerade in der Entwicklung verteilter Systeme Prozesse erleichtert. Die vermutlich bekannteste Implementierung des Modell ist das MQTT-Protokoll, welches konzipiert wurde um Telemetriedeaten zwischen Sensoren und Servern zu übertragen speziell in unzuverlässigen Umgebungen\cite{elektronik_kompendium_publish_subscribe}.
\\

\noindent
Weiter findet das Publish-Subscribe-Modell Anwendung in einer Vielzahl von weiteren Systemen und Technologien. Beispiele dafür sind der \ac{JMS}, der \ac{DDS} oder wie im Fall diese Projektes die \ac{MOM} zu denen auch \ac{ROS} gehört.\\


\section{Pepper}\label{sec:Pepper}
Pepper ist ein humanoider Roboter, der entwickelt wurde, um die Gefühle und Gesten von Menschen zu analysieren und basierend auf diesen, darauf zu reagieren. Das Projekt entstand durch eine Zusammenarbeit des französischen Unternehmens Aldebaran Robotics \ac{SAS} und des japanischen Telekommunikations- und Medienkonzerns SoftBank Mobile Corp. Ziel diese Projektes war es, einen humanuiden ``Roboter-Gefährten'' oder einen ``persönlichen Roboter-Freund'' zu schaffen, der zunächst im Gewerbesektor in Verkaufsräumen, an Empfangstischen oder in Bildungs- und Gesundheitseinrichtungen eingesetzt werden sollte. Die Produktion wurde jedoch aufgrund geringer Nachfrage bis auf Weiteres pausiert.
\\

\noindent
Das Konzept von Pepper distanziert sich von herkömmlichen Industrierobotern und reinen Spielzeugrobotern, indem er als informativer und kommunikativer Begleiter konzipiert wurde. Sein Aussehen, das im etwa an die Größe eines Kindes angelehnt ist, sowie ein freundliches Gesicht und eine kindliche Stimme sind im ästhetischen Konzept von ``kawaii'' (japanisch für ``niedlich'' oder auch ``liebenswert'') gehalten.
\\

\noindent
Pepper wurde im Rahmen einer Präsentation am 5. Juni 2014 als der ``erste persönliche Roboter der Welt mit Emotionen'' vorgestellt. Die Vermarktung begann damit, dass SoftBank Pepper-Geräte in ihren Verkaufsräumen einsetzte, um Kunden zu unterhalten und zu informieren. Die Roboter sollte dabei den Umgang mit Kunden erlernen, um zukünftige Anwendungsmöglichkeiten zu erforschen. Verkauft wurde offiziell ab dem 3. Juli 2015 zu einem Preis von 198.000 Yen pro Einheit, zuzüglich monatlicher Gebühren für Zusatzleistungen. Im Laufe der Zeit wurde Pepper auch für den Einsatz in weiteren Unternehmen und Einrichtungen verfügbar gemacht.
\\

\noindent
Pepper wird mit einer Grundausstattung an Anwendungen geliefert, jedoch sind für spezifische Anwendungen, individuell entwickelte Softwarelösungen erforderlich wie auch zum Beispiel in diesem. SoftBank ermöglichte unabhängigen Entwicklern durch die Veröffentlichung der Schnittstellen den Zugang zu einem Interface für Applikationsprogramme, um zusätzliche Anwendungen für Pepper zu erstellen. Das NAOqi-Framework welches für diesen Nutzen bereitgestellt wurde, beinhaltet eine \ac{API}, eine \ac{SDK} und weitere Tools, welche in den Sprachen Python und C++ uneingeschränkten Zugriff auf die Komponenten, Sensoren und Aktoren des Roboters bieten, dazu später Ausführlicheres in \autoref{sec:NAOqi}. Mit Hilfe diese Interfaces haben verschiedene Unternehmen integrierte Lösungen entwickelt, die Pepper beispielsweise bei der Kundenberatung unterstützen können.
\\

\noindent
Das Design von Pepper ist dem Menschen ähnlich und umfasst einen Kopf mit integrierten Mikrofonen und Kameras sowie einen Torso mit weiteren Sensoren für Stabilität und Sicherheit. Der Roboter verfügt über verschiedene Mechaniken, die es ihm ermöglichen, sich flüssig zu bewegen und mit Personen zu interagieren. Durch die Verwendung von Kameras und bereitgestellter Software ist Pepper in der Lage, Emotionen bei seinen Gesprächspartnern zu erkennen und darauf zu reagieren, obwohl er selbst keine Mimik besitzt. Sicherheitsvorkehrungen wie Abstandssensoren und Stabilisatoren gewährleisten einen sicheren Einsatz von Pepper in verschiedenen Umgebungen. Diese können jedoch bedingt durch den Entwickler deaktiviert werden, um den Roboter in komplexeren oder laborähnlichen Umgebungen zu betreiben.\\


\section{NAOqi}\label{sec:NAOqi}
Im folgenden Abschnitt wird das NAOqi-Framework, welches auf dem Pepper Roboter läuft, genauer erläutert.\\

\subsection{Was ist NAOqi?}\label{subsec:WasIstNAOqi}
NAOqi ist die Bezeichnung für die Hauptsoftware, die auf dem Pepper Roboter ausgeführt wird und ihn intern steuert. Diese kann mit persönlichen Modulen weiterentwickelt und angepasst werden. Dazu können mit Hilfe der Aldebaran \ac{SDK} auch NQOqi-\ac{SDK} genannt, eigene Module oder Bibliotheken entwickelt werden. Diese NAOqi-\ac{SDK} ist die Basis des NAOqi Frameworks und ist in C++ implementiert\cite{nao_dev_install_guide}.
\\

\noindent
Das NAOqi Framework ist das Programmiergerüst, welches zur Programmierung von NAO und Pepper Robotern verwendet wird. Es implementiert alle allgemeinen Anforderungen der Robotik, einschließlich: Parallelität, Ressourcen-Management, Synchronisation und Ereignisse. Dieses Framework ermöglicht eine homogene Kommunikation zwischen verschiedenen Modulen wie etwa die Bewegung, Audio oder Video sowie eine homogene Programmierung und einen homogenen Informationsaustausch. Das Framework ist:\\
\begin{itemize}
    \item plattformübergreifend, wie bereits erwähnt, basiert die NAOqi-\ac{SDK} auf C++ und bietet damit die Möglichkeit auf Windows, Linux oder sogar auch Mac zu entwickeln.
    \item sprachübergreifend, mit einer identischen API für C++ und Python. Weitere Details dazu sind in \autoref{subsubsec:Sprachuebergreifend} aufgeführt.
    \item fähig auf Introspektion, was bedeutet, dass das Framework weiß, welche Funktionen in den verschiedenen Modulen verfügbar sind und wo. Für Details diesbezüglich siehe \autoref{subsubsec:Introspektion}.
\end{itemize}

\subsubsection{Sprachübergreifend}\label{subsubsec:Sprachuebergreifend}
Software kann in C++ und Python entwickelt werden. Eine Übersicht über die Sprachen selbst in den Abschnitten \autoref{subsec:Cpp} und \autoref{subsec:Python}. In allen Fällen sind die Programmiermethoden genau die gleichen, alle vorhandenen \acp{API} können unabhängig von den unterstützten Sprachen aufgerufen werden:\\
\begin{itemize}
    \item Wird ein neues C++-Modul erstellt, können die C++-\ac{API}-Funktionen von überall aus aufgerufen werden,
    \item Sind sie richtig definiert, können auch die \ac{API}-Funktionen eines Python-Moduls von überall aus aufgerufen werden.
\end{itemize}
Normalerweise werden die Verhaltensweisen in Python und Ihre Dienste in C++ entwickelt.\\
\normfig{NAOqi-Framework-Sprachübergreifend}{0.5}{-}

\subsubsection{Introspektion}\label{subsubsec:Introspektion}
Die Introspektion ist die Grundlage der Roboter-\ac{API}, der Fähigkeiten, der Überwachung und der Maßnahmen bei überwachten Funktionen. Der Roboter selbst kennt alle verfügbaren \ac{API}-Funktionen. Wird eine Bibliothek entladen, werden die entsprechenden \ac{API}-Funktionen automatisch ebenfalls entfernt. Eine in einem Modul definierte Funktion kann der \ac{API} mit einem \texttt{BIND\_METHOD} hinzugefügt werden.
\\

\noindent
Wird eine Funktion gebunden, werden automatisch folgende Funktionen ausgeführt:\\
\begin{itemize}
    \item Funktionsaufruf in C++ und Python, wie in \autoref{subsubsec:Sprachuebergreifend} beschrieben
    \item Erkennen der Funktion, wenn sie gerade ausgeführt wird
    \item Funktion lokal oder aus der Ferne, z.B. von einem Computer oder einem anderen Roboter, ausführen weiter im Detail beschrieben in \autoref{subsubsec:VerteilterBaumUndKommunikation}
    \item Generierung und Aufruf von \texttt{wait}, \texttt{stop}, \texttt{isRunning} in Funktionen
\end{itemize}
Die \ac{API} wird im Webbrowser angezeigt wenn auf das Gerät per \ac{URL} oder \ac{IP}-Addresse auf dem Port 9559 zugegriffen wird. In dieser Übersicht, zeigt der Roboter seine Modulliste, Methodenliste, Methodenparameter, Beschreibungen und Beispiele an. Der Browser zeigt auch parallele Methoden an, die überwacht, zum Warten veranlasst und gestoppt werden können.
\\

\noindent
Die Introspektion und derer Implementation im NAOqi-Framework, ist also ein nützliches Werkzeug, welches es ermöglicht, die Roboter-\ac{API} zu verstehen und zu verwenden aber auch zu überwachenund zu steuern.\\
\normfig{NAOqi-Framework-Introspektion}{0.5}{-}

\subsubsection{Verteilter Baum und Kommunikation}\label{subsubsec:VerteilterBaumUndKommunikation}
Eine Echtzeitanwendung kann aus einer einzelnen ausführbaren Datei oder einem Baum von mehreren Systemen wie etwa Robotern, Prozessen oder Modulen bestehen. Unabhängig davon sind die Aufrufmethoden immer dieselben. Eine ausführbare Datei kann durch eine Verbindung mit einem anderen Roboter mit \ac{IP}-Adresse und Port verbunden werden, sodass alle \ac{API}-Methoden von anderen ausführbaren Dateien sind auf die gleiche Weise verfügbar sind, genau wie bei einer lokalen Methode. NAOqi trifft dabei selbst die Wahl zwischen schnellem Direktaufruf \ac{LPC} und Fernaufruf \ac{RPC}.\\
\normfig{NAOqi-Framework-Kommunikation}{0.5}{-}

\subsection{NAOqi Vorgehensweise}\label{subsec:NAOqiVorgehensweise}
Die NAOqi Software, welche auf dem Roboter läuft, ist ein Broker. Wenn dieser startet, lädt er eine Voreinstellungsdatei in den Speicher, in der festgelegt ist, welche Bibliotheken in dieser Konfiguration geladen werden sollen. Jede Bibliothek enthält ein oder mehrere Module, die den Broker benutzen, um ihre Methoden bereitzustellen.\\
\normfig{NAOqi-Broker-Bibliotheken-Module}{0.5}{-}
\noindent
Der Broker selbst bietet Nachschlagdienste an, so dass jedes Modul im Baum oder im Netzwerk jede Methode finden kann, die an dem Broker bekannt gegeben wurde.\\
Das Laden von Modulen bildet dann einen Baum von Methoden, die mit Modulen verbunden sind, und von Modulen, welche mit dem Broker verbunden sind.\\
\normfig{NAOqi-Broker-Modul-Methoden}{0.5}{-}

\subsubsection{NAOqi Proxy}\label{subsubsec:NAOqiProxy}
Ein weiterer wichtiger Bestandteil des NAOqi Broker ist der Proxy welcher grundlegend die Aufgabe eines Modules, näher beschrieben im folgenden \autoref{subsec:NAOqiModule}, repräsentiert. Dies kann lokal oder entfernt enstehen der einzige Unterschied dabei ist, dass bei einer entfernten Refernz die \ac{IP} des entfernten Broker mit angegeben werden muss, gleich bleibt aber im internen, dass der Proxy die Methoden des Moduls an den Broker weiterleitet.\\

\subsection{NAOqi Module}\label{subsec:NAOqiModule}
Module sind die Grundbausteine der personalisierten Gestaltung von NAOqi. In ihnen kann der Nutzer eigene funktionaitäten implementieren und diese dem Broker bereitstellen. Ein Modul kann dabei aus einer oder mehreren Klassen bestehen, die wiederum Methoden enthalten.
\\

\noindent
Standardmäßig ist jedes Modul eine Klasse innerhalb einer Bibliothek, welche über eine \texttt{autoload.ini}-Datei geladen wird, worauf die Modulklasse automatisch instanziiert wird.
\\

\noindent
Weiter können auch Module von übergeordneten Module abgeleitet werden, ähnlich wie etwa bei der Vererbung in der objektorientierten Programmierung. Wird eine Klasse voneiner anderen abgeleitet, können die Methoden gebunden werden, wodurch ihre Namen und MethodenSignaturen direkt dem Broker bekannt gemacht werden.
\\

\noindent
Weiter können, wie bereits erwähnt, Module sowohl lokal als auch entfernt implementiert werden. Ist es ein solches entferntes Modul, wird es als ausführbare Datei kompiliert, und kann auch außerhalb des Roboters ausgeführt werden.
\\

\noindent
Unabhängig jedoch von der Lagerung der Module, enthält jedes Modul eine Bandbreite von Methoden, welche wie im \autoref{subsubsec:Introspektion} beschrieben, gebunden werden können und damit nach außen hin nutzbar gemacht werden. Es ist also unabhängig der Lagerung der Module möglich, diese in der gleichen Weise aufzurufen. Module passen sich also automatisch selbst an.\\

\subsubsection{Entfernte Module}\label{subsubsec:EntfernteModule}
Entfernte Module sind Module, die über das Netzwerk kommunizieren, dies kann auf demselben Robotter sein, also auch auf einem anderen Gerät im Netzwerk. Ein entferntes Modul braucht einen entfernten Broker, um mit anderen Modulen zu kommunizieren, da es selbst keinen eigenen besitzt. Broker sind dann für den gesamten Netzwerkteil verantwortlich. Über diesen Umweg über das Netzwerk können keine schnellen Zugriffe über Remote-Module durchgeführt werden wie etwa direkte Speicherzugriffe.
\\

\noindent
Diese entfernten Module sind trivialer in der Handhabung, da sie außerhalb des Systems entwickelt und debugged werden. Dagegen sind sie aber in der Laufzeit selbst deutlich schwächer in den Punkten Geschwindigkeit und Speichernutzung, gegenüber iherer lokalen Gegenstücke. Diese Funktionalität der entfernten entwicklung spielt speziell in der Implementierung dieses Projektes eine grundlegende Rolle.\\

\subsubsection{Lokale Module}\label{subsubsec:LokaleModule}
Lokale Module werden als Bibliotheken kompiliert und nur auf dem Roboter verwendet. Dadurch sind sie schneller und effizienter in der Laufzeit als auch in der Speicherverwaltung, dagegen ist die Entwicklung und das Debugging auf dem Roboter selbst deutlich aufwendiger.
\\

\noindent
Sie bestehen aus zwei oder mehr Module, welche auf dem Roboter im selben Prozess gestartet werden. Sie kommunizieren miteinander über denselben Broker.\\
Da sich lokale Module im selben Prozess befinden, können diese Variablen gemeinsam nutzen und die Methoden des jeweils anderen ohne Serialisierung oder Vernetzung aufrufen. Dies ermöglicht die schnellstmögliche und maximal effiziente Kommunikation zwischen den Modulen.\\

\subsection{NAOqi Speicherverwaltung}\label{subsec:NAOqiSpeicherverwaltung}
Die Speicherverwaltung in NAOqi wird von dem Modul \texttt{ALMemory} übernommen. Dieses Modul ist ein Speicher welcher sowohl Daten als auch Ereignisse beinhaltet. Dieser Speicher wird von allen Modulen geteilt und ermöglicht es, Daten zwischen den Modulen auszutauschen. Zusätzlich werden in diesem Speicher auch alle Ereignisse zwischengespeichert, auf welchen dann die abonierten Module zugreifen können, sobald das Ereigniss ausgelöst wurde. Alle Module haben auf diesen Bereich sowohl Lese- als auch Schreibzugriff. Jedoch ist das \texttt{ALMemory} Modul kein Echtzeitsynchronisationstool. Abonieren auf Bewegungsdatendaten oder Echtzeitvariablen in diesem Speicher ist also risikobehaftet.
\\

\noindent
Das Modul selbst ist ein Array aus sogenannten \texttt{ALValue}-Objekten, auf welche thread-sicher zugegriffen werden kann. In diese Speicherbausteine können alle gängigen Datentypen gelegt werden. Dazu zählen einfache Datentypen wie einzelne Bits, Ganzzahlen, Fließkommazahlen und Zeichenketten, aber auch komplexere Datenstrukturen wie Arrays, Matrizen und Binaries.
\\

\noindent
Standardmäßig wird zwischen drei verschiedenen Datentypen unterschieden:\\
\normfig{NAOqi-Framework-Speicherverwaltung}{0.5}{-}
\begin{itemize}
    \item Daten von Sensoren und Gelenken: diese Daten werden vom Roboter selbst in den Speicher geschrieben und haben keine Historie. Sie sind nicht größer als 32-Bit und können direkt per Pointer aufgerufen werden.
    \item Ereignisse: auf welche aboniert werden muss. Sobald eines dieser Ereignisse ausgelöst wird, wird es im Speicher gespeichert und kann von den abonierten Modulen abgerufen werden. Im Gegensatz zu den Daten von Sensoren und Gelenken sowie den Micro-Ereignissen, haben diese Ereignisse eine Historie und können auch nach dem Auslösen noch abgerufen werden.
    \item Micro-Ereignisse: Diese Ereignisse sind sehr kurzlebig und werden sofort nach dem Auslösen wieder gelöscht. Sie werden nicht im Speicher gespeichert und haben daher keine Historie.
\end{itemize}


\section{Middleware}\label{sec:Middleware}
Middleware ist eine Software, die zwischen Anwendungen und Betriebssystemen vermittelt. Sie ermöglicht die Kommunikation zwischen verschiedenen Anwendungen, die auf unterschiedlichen Plattformen oder in unterschiedlichen Netzwerken ausgeführt werden. Middleware bietet eine Reihe von Diensten, die die Verbindung von Anwendungen erleichtern, die eigentlich nicht dafür vorgesehen sind. Dadurch, sowie durch Bereitstellung von weiteren Diensten wie etwa Sicherheit, Skalierbarkeit und Zuverlässigkeit, rationalisiert Middleware die Entwicklung, Bereitstellung und Wartung von Anwendungen.
\\

\noindent
Middleware existiert in verschiedenen Formen, wie etwa Nachrichtenbroker oder Transaktionsverarbeitungsmonitore, welche jeweils auf spezifische Kommunikationsformen zugeschnitten sind. Andere, wie etwa Webanwendungsserver oder Middleware für mobile Geräte, bieten ein breites Spektrum an Kommunikations- und Konnektivitätsfunktionen, die für die Entwicklung bestimmter Anwendungen im Mobilebereich unabdinglich sind. Wieder andere, wie etwa der \ac{ESB}, fungiert als zentraler Integrationsknotenpunkt, der alle Komponenten in einem Unternehmen miteinander verbindet. Zusätzlich können aber auch persönliche Middleware selbst entwickelt werden, für personalisierte Anwendungen.
\\

\noindent
Der Begriff ``Middleware'' wurde geprägt, da die erste Generation dieser oft als ``Vermittler'' zwischen einem Anwendungs-Frontend zum Beispiel eines Clients und einer Backend-Ressource, in welcher Daten gespeichert oder verarbeitet werden, fungierte. Dabei kann, auch wie in \autoref{img:Middleware} gezeigt, das Betriebsystem das Backend sein und eine Anwendung das Frontend.\\
\normfig{Middleware}{0.5}{-}
Die moderne Middleware heutzutage beinhaltet jedoch durchaus einen weitaus breiteren Aufgabenbereich. Beispielsweise umfasst Portal-Middleware sowohl das Frontend der Anwendung als auch Tools für die Backend-Konnektivität, während Datenbank-Middleware in der Regel einen eigenen Datenspeicher enthält \cite{AzureMiddleware}.
\\

\noindent
In diesem Projekt wird die Middleware \ac{ROS} 2 genutzt, welche speziell für die Entwicklung von Robotersoftware entwickelt wurde und daher eine Vielzahl von Funktionen und Diensten bietet, die speziell auf die Anforderungen derer zugeschnitten sind.\\

\section{Robot Operating System 2}\label{sec:ROS2}
\ac{ROS} 2 ist eine Middleware zur entwickeln von Software für Roboter. Sie ist stark typisiert und basiert auf einem anonymen Publish-Subscribe-Mechanismus, welcher die Weitergabe von Nachrichten zwischen verschiedenen Prozessen ermöglicht.
\\

\noindent
Das Herzstück eines jeden \ac{ROS} 2-Systems ist der \ac{ROS}-Graph. Er bezieht sich auf das Netzwerk von Knoten in einem \ac{ROS}-System und die Verbindungen zwischen ihnen, über welche sie komunizieren \cite{ROSBasicConcepts}.
\\

\noindent
Im Folgenden wird näher auf die in diesem Projekt verwendeten Konzepte und Technologien von \ac{ROS} 2 eingegangen.\\

\subsection{Nodes}\label{subsec:ROS2Nodes}
Eine Node, auch Knoten genannt, ist eine Nutzer-Bibliothek zur Kommunikation mit anderen Nodes. Diese können mit anderen Nodes, innerhalb eines Prozesses, in einem anderen Prozess oder auf einem anderen Rechner kommuniziert werden. Sie sind häufig die Einheit der Berechnung in einem \ac{ROS}-Graphen. Dabei sollte jede Node eine logische Aufgabe erfüllen.
\\

\noindent
Nodes haben die Möglichkeit, bestimmte Topics zu veröffentlichen, um Daten an andere Nodes zu übermitteln oder bestimmte Themen zu abonnieren (subscriben), um Daten von anderen Nodes zu erhalten. Es ist möglich, dass Sie entweder als Service-Client agieren, um eine Berechnung in ihrem Namen durchzuführen, oder als Service-Server, um anderen Nodes Funktionen zur Verfügung zu stellen. Eine Node kann als Aktionsrechner fungieren, um eine weitere Node zu beauftragen, die Berechnung in ihrem Namen durchzuführen oder als Aktionsserver für wiederum weitere Nodes als Funktionen bereitzustellen. Nodes können zusätzlich konfigurierbare Parameter bereitstellen, um das Verhalten während der Laufzeit individuell anzupassen.
\\

\noindent
Eine Node ist oft eine komplexe Kombination aus Publishern, Subscribern, Service-Servern, Services-Clients, Action-Servern und Action-Servern und werden über einen verteilten Erkennungsprozess identifiziert \cite{ROSNodes}.
\\

\noindent
Eine solche Node wird in diesem Projekt für die Kommunikation und Übersetzung verschiedener Daten für den Pepper Roboter entwickelt.\\

\subsection{Topics}\label{subsec:ROS2Topics}
Topics sind ein Mechanismus, um Nachrichten zwischen Nodes zu übertragen. Sie sind asynchron, strikt typisiert, anonym und ermöglichen die Kommunikation zwischen Nodes, ohne dass diese voneinander Kenntnis haben müssen. Dies ist möglich durch die Nutzung des Publish-Subscribe-Prinzip. Dieses wurde zwar schon in den Abschnitten \autoref{sec:NAOqi} und speziell \autoref{sec:PublishAndSubscribe} erläutert, wird jedoch hier noch einmal im Kontext von \ac{ROS} 2 aufgegriffen.
\\

\noindent
In \ac{ROS} 2 können Nodes sowohl Produzenten sein und Daten in ein Topic veröffentlichen, als auch Konsumenten, die Daten aus einem Topic abonnieren. Die Nodes selbst können dabei beliebig viele Topics abonnieren oder veröffentlichen.
\\

\noindent
Dabei ist der Begriff Topic lediglich der Name unter dem die Nachrichten veröffentlicht und auch abgerufen werden können. Die Nachrichten selbst sind dabei in einem strikt typisierten Format, welches als Message bezeichnet und definiert wird und im \autoref{subsubsec:ROS2Messages} ganuer erläutert wird.
\\

\noindent
Werfen wir jedoch zunächst einen genaueren Blick auf die Deteils der Bedeutungen der Anonymität und der strikten typisierung im Kontext von \ac{ROS} 2:\\

\subsubsection{Anonymität}\label{subsubsec:ROS2Anonymitaet}
Die Anonymität in \ac{ROS} 2 bezieht sich darauf, dass die Nodes, die Daten in ein Topic veröffentlichen oder von einem Topic abonnieren, nicht wissen, welche anderen Nodes ebenfalls auf dieses Topic zugreifen und primär von welcher Node sie überhaupt stammen. Dies ermöglicht eine lose Kopplung zwischen den Nodes, da sie nicht auf die Existenz oder den Zustand der anderen Nodes angewiesen sind. Dadurch werden \ac{ROS} 2 Systeme flexibel und Nodes können durch die genannte Entkopplung völlig frei entwickelt, ausgetauscht und aus technischer Sicht auch gelöscht werden.\\

\subsubsection{Strikte Typisierung}\label{subsubsec:ROS2StrikteTypisierung}
\ac{ROS} 2 Nodes können zwar sowohl in Python als auch in C++ entwickelt werden, was zumindest auf Seiten der Python-Entwicklung eine dynamische Typisierung implizieren könnte, jedoch bildet sich diese Freiheit nicht auf die Nachrichten (Messages) ab, da diese auch im Raum der in C++ strikt typisiert ist, genutzt werden müssen. Dadurch ergeben sich die in den Interfaces definierten, strikten Typen, die von den Nodes eingehalten werden müssen. Dies ermöglicht eine einfache und effiziente Kommunikation zwischen den Nodes, sollten diese auch in verschiedenen Sprachen implementiert sein, da die Nachrichten immer in einem festen Format vorliegen und die Nodes sich darauf verlassen können, dass die Nachrichten korrekt sind.
\\

\noindent
Weiter werden die Nachrichten auch semantisch strikt typisiert, was bedeutet, dass die Nachrichten auch inhaltlich korrekt sind und die Nodes sich darauf verlassen können, dass die Nachrichten die erwarteten Daten enthalten. Ein anschauliches Beispiel dafür sind die sogenannten \ac{IMU}-Messages. Sie enthalten als Datentyp ein dreidimensionales Array aus Fließkommazahlen, welche die Beschleunigung, die Winkelgeschwindigkeit und die Magnetfeldstärke eines Sensors in den drei Raumrichtungen beschreiben. Also ist nicht nur der Datentyp strikt festgelegt, sondern auch die einzelnen Werte und deren Reihenfolge, die in den Arrays enthalten sind \cite{ROSTopics}.\\

\subsection{Interfaces}\label{subsec:ROS2Interfaces}
\ac{ROS} 2 kommuniziert typischerweise über verschiedene Schnittstellen (Interfaces), die als Messages, Services und Actions bezeichnet werden. \ac{ROS} 2 verwendet dabei eine vereinfachte Beschreibungssprache, um die Interfaces zu definieren, die als \ac{IDL} bezeichnet wird. Diese Beschreibungssprache wird verwendet, um die Interfaces in verschiedenen Programmiersprachen zu generieren \cite{ROSInterfaces}.
\\

\noindent
Dabei bietet \ac{ROS} 2 drei Typen von Interfaces welche folgend erläutert werden:\\

\subsubsection{Messages}\label{subsubsec:ROS2Messages}
Messages werden in Topics genutzt und sind einfache Textdateien, die die Felder einer \ac{ROS}-Nachricht beschreiben. Diese Nachrichten werden verwendet, um Source-Code für die Nachrichten zu generieren, die in verschiedenen Programmiersprachen verwendet werden können.
\\

\noindent
Die Messages sind eine Möglichkeit für Nodes, Daten über das Netzwerk mit weiteren Nodes auszutauschen, auch wenn keine Antwort erwartet wird. Als Beispiel kann eine Node eine Nachricht veröffentlichen, die die Daten eines Sensors enthält, und eine andere Node kann diese Nachricht abonnieren, ohne dass die erste Node eine Antwort erwartet oder überhaupt von der Existenz der zweiten Node weiß.
\\

\noindent
Die \texttt{.msg}-Dateien, welche die Messages beschreiben, werden in einem separaten Verzeichnis im \ac{ROS}-Paket unter \texttt{msg/} abgelegt. Sie beinhalten die Felder der Nachricht und Konstanten. Inhalt dieser Felder können nahezu alle gängigen Datentypen sein, wie etwa Ganzzahlen (Integer), Fließkommazahlen (Float), einzelne Zeichen (Char), Zeichenketten (String) aber auch statische Arrays. Einzige Einschränkung sind hierbei die Regelungen (Conventions) von \ac{ROS} 2, welche die Verwendung von alphabetischen Zeichen zu Beginn und Unterstrichen zur Trennung einzelner Wörter im Namen der Felder vorschreiben.
\\

\noindent
Ein typischer Eintrag einer solchen Datei könnte, beispielhaft für die verschiedenen Felder, etwa wie folgt aussehen:\\
\code{ROS 2 Message}{ROS-2-Message.msg}

\subsubsection{Services}\label{subsubsec:ROS2Services}
Services sind im Gesensatz zu den Messages eine synchrone Kommunikation zwischen zwei Nodes. Ein Node sendet eine Anfrage an einen anderen Node und wartet auf dessen Antwort.
\\

\noindent
Sie werden ebenfalls in einem separaten Verzeichnis im \ac{ROS}-Paket unter \texttt{srv/} als \texttt{.srv} Datei abgelegt und beschreiben die Anfrage und die Antwort, die von einem Service bereitgestellt wird. Auch hier folgt der Inhalt der Datei einem festgelegtem Schema ähnlich dessen der Message Dateien, mit dem Zusatz, dass hier getrennt von einer Zeile mit drei Bindestrichen als Inhalt \texttt{---}, auch die zu erwartende Antwort definiert wird.
\\

\noindent
Eine einfach gehaltene \texttt{.srv}-Datei könnte also etwa wie folgt aussehen:\\
\code{ROS 2 Service}{ROS-2-Service.srv}
Auch hier können wie bei den Messages auch komplexere Datenstrukturen, Konstanten und Standardwerte genutzt werden.\\

\subsubsection{Actions}\label{subsubsec:ROS2Actions}
Actions sind eine Erweiterung der Services, die es ermöglichen, asynchrone, lang laufende Prozesse mit beidseitiger Kommunikation zu definieren. Im Gegensatz zu den Services, bei denen die Antwort direkt erwartet wird, können Actions mehrere Sekunden bis Minuten dauern. Diese Action kann in diesem Zeitraum auch unterbrochen und wieder aufgenommen werden, oder sogar ganz abgebrochen werden.
\\

\noindent
Auch Actions werden in einem separaten Verzeichnis im \ac{ROS}-Paket unter \texttt{action/} als \texttt{.action} Datei abgelegt und beschreiben in einer ähnlichen Weise wie die Services und die Messages das erwartete Verhalten. In Gegensatz zu den beiden anderen Schnittstellen, wird hier jedoch nicht die Anfrage und die Antwort definiert, sondern ein Ziel, eine Rückmeldung und ein Feedback, welche im Schema gehalten durch einen Dreifachbindestrich \texttt{---} getrennt werden.\\
Nehmne wir zur Veranschaulichung die \texttt{Fibonacci} \texttt{.action}-Datei als Beispiel:
\\

\noindent
\code{ROS 2 Action}{ROS-2-Action.action}
Es wird ein \texttt{Int32} abgeschickt und daraufhin ein Array aus wiederum \texttt{Int32} erwartet, mit den berechneten Werten. Während der Berechnung wird ein Feedback in Form eines \texttt{Int32} zurückgegeben, mit dem Stand bis zu einem bestimmten Zeitpunkt.\\


\subsection{Parameter}\label{subsec:ROS2Parameter}
Parameter in \ac{ROS} 2 sind direkt verbunden mit den einzelnen Nodes. Sie werden genutzt, um die Konfiguration der Nodes beim Start un zur Laufzeit zu verwalten, ohne den darunterliegenden Code anpassen zu müssen. Die Lebenszeit der Parameter ist dabei an die Lebenszeit der Nodes gebunden, was bedeutet, dass die Parameter beim Start der Nodes geladen werden und beim Beenden der Nodes verfallen. Eine Node kann jedoch eine Art Persistenz implementieren um die Parameter zu speichern und wieder zu verwenden.
\\

\noindent
Jeder dieser Parameter besteht aus einem Schlüssel (Key), einem Wert (Value) und einer Beschreibung (Descriptor). Während der Schlüssel ein \texttt{String} ist und den Parameter identifiziert, ist der Wert der eigentliche Inhalt des Parameters und wird zunächst als Typ definiert. Die Beschreibung ist optional und Standardmäßig \texttt{NULL}. Sie dient dazu, den Parameter zu beschreiben und zu dokumentieren, wie Typ-Informationen, Wertebereiche, Nutzungsdeteils und weitere Informationen welche zur Nutzung relevant sein können.
\\

\noindent
Zu Beginn der Laufzeit muss einen Node definieren welche Parameter diese aktzeptiert, und ob diese optional oder zwingend sind. Dies reduziert die Anfälligkeit auf Fehler in der Konfiguration im späteren Verlauf der Laufzeit. Die Parameter können dann auch zur Laufzeit über die \ac{API} der Nodes abgerufen, gesetzt und gelöscht werden. Einige Arten von Nodes können auch Parameter aktzeptieren bevor diese bekannt sind. Dazu stellt \ac{ROS} 2 den Parameter \texttt{allow\_undeclared\_parameters} zur Verfügung, welcher es bei aktivierung ermöglicht, dass Parameter gesetzt werden können, auch wenn sie nicht explizit in der Parameterliste der Node definiert sind. Dies ist allerdings nur möglich bei neu hinzugefügten Parametern, bereits vorhandene Parameter können nicht zur Laufzeit verändert werden. Dies würde die Grundlage der strikten Typisierung und der semantischen Korrektheit der Parameter verletzen und damit das gesamte System instabillisieren. Versuche dies trotzdem zu tun, werfen einen Fehler und die Node wird sofort terminiert.
\\

\noindent
Soll der Wert eines Parameters zur Laufzeit geändert werden, gibt es dazu zwei Möglichkeiten:
\\

\noindent
\begin{itemize}
    \item Die \texttt{set\_parameters} Methode, welche über die \ac{API} der Node aufgerufen wird und die Parameterwerte ändert. Diese Methode setzt die gewünschten Parameterwerte und gibt die tatsächlich gesetzten Werte zurück, auch wenn die Node die Werte nicht akzeptiert hat. Dies ermöglicht es, die Parameterwerte zu überprüfen und gegebenenfalls zu korrigieren oder gar abzulehnen.
\\

\noindent
    \item Die \texttt{on\_parameter\_event} Methode, welche aufgerufen wird, wenn sich ein Parameterwert ändert. Dadurch wird es der Node und dem User ermöglicht, auf Änderungen der Parameterwerte zu reagieren welche von anderen Nodes oder von der \ac{CLI} zur Laufzeit vorgenommen wurden.\\
\end{itemize}
Zur allgemeinen Interaktion mit den Parametern, bietet \ac{ROS} 2 neben den bereits genannten, eine Vielzahl von \ac{API}-Methoden, auch \ac{API}-Services genannt, um die Parameter zu verwalten. Diese werden standardmäßig bei Initiierung einer Node geladen und bereitgestellt \cite{ROSParameters}.\\

\subsection{Start}\label{subsec:ROS2Start}
Eine \ac{ROS} 2 Anwendung besteht im Allgemeinen aus mindestens einer, aber oft auch mehreren Nodes, die nach dem \ac{ROS}-Pfad abgearbeitet werden und miteinander kommunizieren. Es zwar möglich diese Nodes einzeln, manuell zu starten, jedoch ist es in der Praxis üblich, die Nodes in einem Launch-File (Start-Datei) zu starten. Sie trägt die Endung \texttt{.launch.[Format]} und kann in Python (\texttt{.launch.py}), \ac{XML} (\texttt{.launch.xml}) oder \ac{YAML} (\texttt{.launch.yaml}) geschrieben werden. Ein Launch-File ist eine Python-Datei, die die Konfiguration der Nodes und die Verbindung zwischen ihnen beschreibt. Sie kann auch Parameter, Argumente und Umgebungsvariablen enthalten, die von den Nodes verwendet werden.
\\

\noindent
Allgemein ist das Startsystem von \ac{ROS} 2 dazu designed mehrere Nodes gleichzeitig zu starten und zu verwalten durch eine einzige Datei. Es verbessert die Wartbarkeit und die Skalierbarkeit der Anwendung ungemein und ermöglicht in der Überwachung einen deutlich vereinfachten Überblick über die laufenden Komponenten \cite{ROSLaunch}.\\

\subsection{Nutzer Bibliotheken}\label{subsec:ROS2NutzerBibliotheken}
Client-Libraries (Nutzer Bibliotheken) sind eine Reihe an \ac{API}s und Tools, die es Entwicklern ermöglichen, \ac{ROS} 2-Bausteine in verschiedenen Programmiersprachen selbst zu schreiben. Dazu zählen neue Nodes, Topics, Services und andere \ac{ROS} 2-Bausteine. Auch bei den Programmiersprachen bietet \ac{ROS} 2 mehrere Möglichkeiten, um dem Nutzer die Wahl zu lassen und die Komponente bestmöglich an die Anforderungen des Nutzens anzupassen. Bausteine welche eher für die Visualisierung entwickelt wurden, werden in Python geschrieben, während Bausteine, die eine hohe Rechenleistung benötigen oder echtzeitfähig sein müssen, werden eher in C++ geschrieben.\\

\subsubsection{rclcpp}\label{subsubsec:ROS2rclcpp}
Die \ac{ROS}-Client-Bibliothek für C++ (rclcpp) ist die benutzerorientierte, idiomatische C++-Schnittstelle, die alle \ac{ROS}-Client-Funktionen wie das Erstellen von Knoten, Publishern und Abonnements bereitstellt. Rclcpp baut auf \ac{rcl} und der \ac{ROS}\ac{IDL}-\ac{API} auf und ist für die Verwendung mit den von \texttt{rosidl\_generator\_cpp} erzeugten C++-Nachrichten konzipiert.
\\

\noindent
Rclcpp nutzt alle Funktionen von C++ und C++17, um die Schnittstelle so einfach wie möglich zu gestalten. Da es jedoch die Implementierung in \ac{rcl} wiederverwendet, ist es in der Lage, ein konsistentes Verhalten mit den anderen Client-Bibliotheken, die die \ac{rcl}-\ac{API} verwenden, beizubehalten.\\

\subsubsection{rclpy}\label{subsubsec:ROS2rclpy}
Die \ac{ROS}-Client-Bibliothek für Python (rclpy) ist das Python-Gegenstück zur C++-Client-Bibliothek. Wie die C++-Client-Bibliothek auch, baut auch rclpy für seine Implementierung auf der \ac{rcl} C \ac{API} auf. Die Schnittstelle bietet ein idiomatisches Python-Erlebnis, das native Python-Typen und -Muster wie Listen und Kontextobjekte verwendet. Durch die Verwendung der \ac{rcl}-\ac{API} in der Implementierung bleibt die Konsistenz mit den anderen Client-Bibliotheken in Bezug auf Funktionsgleichheit und Verhalten erhalten. Die Python-Client-Bibliothek stellt nicht nur idiomatische Python-Bindungen für die \ac{rcl}-\ac{API} und Python-Klassen für jede Nachricht bereit, sondern kümmert sich auch um das Ausführungsmodell, indem sie \texttt{threading.Thread} oder eine ähnliche Methode verwendet, um die Funktionen der \ac{rcl}-\ac{API} auszuführen.
\\

\noindent
Wie auch bei C++ generiert sie benutzerdefinierten Python-Code für jede \c{ROS}-Nachricht, mit der der Benutzer interagiert, aber im Gegensatz zu C++ konvertiert sie schließlich das native Python-Nachrichtenobjekt in die C-Version der Nachricht. Alle Operationen erfolgen mit der Python-Version der Nachrichten, bis sie an die \ac{ROS}-Schicht weitergegeben werden müssen. Dann werden sie in die einfache C-Version der Nachricht umgewandelt, damit sie an die \ac{ROS}-C-\ac{API} weitergegeben werden kann. Dies wird nach Möglichkeit vermieden, wenn die Kommunikation zwischen Herausgebern und Abonnements im selben Prozess erfolgt, um die Konvertierung in und aus Python zu reduzieren.\\

\subsubsection{Weitere}\label{subsubsec:ROS2Weitere}
Neben den von \ac{ROS} 2 bereitgestellten Client-Bibliotheken, gibt es auch weitere von der Community entwickelte Bibliotheken. Diese Bibliotheken bieten zusätzliche Unterstützung für weitere Sprachen, sind dadurch jedoch nicht so tief in das System integriert, werden teilweise nicht aktiv weiterentwickelt und teilweise sogar schon als Projekt eingestellt.
\\

\noindent
Zu diesen Bibliotheken zählen:\\
\begin{itemize}
    \item \texttt{rclc} - welche die FUnktionalität von \texttt{rcl} nicht ersetzt sondern um einige nützliche Funktionen erweitert.\\
    \item \texttt{rcljava} - eine Java-Client-Bibliothek zur Unterstüzung von \ac{JVM}-Basierten Sprachen und Android-Java.\\
    \item \texttt{rclcs} - eine C\#-Client-Bibliothek für .NET- und .NET-Core-Entwickler.\\
    \item \texttt{rclnodejs} - eine Node.js-Client-Bibliothek für die Enticklung in JavaScript.\\
    \item \texttt{rclrs} - eine Reihe an Projekten, welch die Entwicklung von \ac{ROS} 2 in Rust unterstützen.\\
\end{itemize}
Ältere Bibliotheken, die nicht mehr aktiv weiterentwickelt werden, sind:\\
\begin{itemize}
    \item \texttt{Ada}
    \item \texttt{iOS}
    \item \texttt{Zig}
\end{itemize}


\section{Colcon}\label{sec:Colcon}
Colcon ist ein Kommandozeilenwerkzeug zur Verbesserung des Arbeitsablaufs beim Erstellen, Testen und Verwenden mehrerer Softwarepakete. Es automatisiert den Prozess, übernimmt die Bestellung und richtet die Umgebung für die Nutzung der Pakete ein \cite{colcon_docs}. Der Fokus der Software liegt primär auf:\\
\begin{itemize}
    \item Das Werkzeug sollte das Builden, Testen und Verwenden mehrerer Pakete vereinfachen.
    \item Es sollte möglich sein, Unterstützung für jede Art von Build-System mit Hilfe von Erweiterungen hinzuzufügen. Colcon-core bündelt nur Python-Unterstützung, um sich selbst zu booten.
    \item Es sollte möglich sein, eine beliebige Menge von Paketen zu bauen, ohne dass Änderungen an den Quellen erforderlich sind. Falls nötig, können fehlende Informationen von außen nachgeliefert werden.
    \item Nach dem Build der Pakete müssen diese sofort nutzbar sein, was das Einrichten der notwendigen Umgebungsvariablen und weiteren Abhängigkeiten einschließt.
    \item Die gesamte bereitgestellte Funktionalität sollte so offengelegt werden, dass sie von anderen Erweiterungen wiederverwendet werden kann.
    \item Die Aufteilung in mehrere Python-Pakete wird genutzt, um Modularität und lose Kopplung zu fördern. Sie wird auch verwendet, um die Erweiterbarkeit zu demonstrieren und zu zeigen, dass bestimmte Funktionen nicht ``speziell'' sind, sondern von außen beigesteuert werden können.
\end{itemize}


\section{Programming Languages}
Wie bereits in \autoref{subsec:ROS2NutzerBibliotheken} erwähnt, bietet \ac{ROS} 2 die Möglichkeit, Nodes in verschiedenen Programmiersprachen zu schreiben. Dabei sind die beiden Hauptprogrammiersprachen, die von \ac{ROS} 2 unterstützt werden, C++ und Python. 
\\

\noindent
Für die Entwicklung in den Entwicklungsumgebungen für die VR-Brille wird C\# verwendet, deshalb wird auch diese Programmiersprache im folgenden vorgestellt.

\subsection{C++}\label{subsec:Cpp}
C++ ist eine von Bjarne Stroustrup entwickelte, weit verbreitete Programmiersprache, die ursprünglich als Erweiterung der Programmiersprache C konzipiert wurde \cite{CppWikipedia}. Sie ist bekannt für ihre Leistungsfähigkeit und Flexibilität. Die Sprache bietet Funktionen wie starke Typisierung, effiziente Ressourcenverwaltung und die Möglichkeit der Hardwarezugriffssteuerung, was sie zu einer beliebten Wahl für die Entwicklung von Systemsoftware, Betriebssystemen und Embedded-Programmierung macht.
\\

\noindent
C++ verfügt über eine umfangreiche Standardbibliothek \texttt{std} sowie eine große Anzahl von Open-Source-Bibliotheken und Frameworks, die von der Community entwickelt wurden. Sie bieten eine Vielzahl von weiteren nützlichen Anwendungen, wie etwa numerische Berechnungen, Grafikprogrammierung, Netzwerkprogrammierung und Einige mehr. Beliebte Bibliotheken und Frameworks für C++ sind zum Beispiel \texttt{Boost} für allgemeine Zwecke, \texttt{Eigen} für lineare Algebra, \texttt{\ac{SFML}} und \texttt{OpenGL} für Grafiken und Spieleentwicklung, sowie \texttt{Poco} für Netzwerk- und Systemprogrammierung \cite{CppBibliotheken}.\\
C++ ist aufgrund seiner Leistungsfähigkeit, Flexibilität und weit verbreiteten Anwendung in verschiedenen Branchen eine beliebte Wahl für die Entwicklung von Softwareprojekten, insbesondere solchen, die eine hohe Leistung und effiziente Ressourcennutzung erfordern, wie etwa bei Robottern. Die Vielseitigkeit von C++ ermöglicht es Entwicklern, Anwendungen von kleinen Embedded-Systemen bis hin zu großen verteilten Systemen zu entwickeln.\\

\subsection{Python}\label{subsec:Python}
Python ist eine interpretierte High-Level-Programmiersprache, die erstmals 1991 von Guido van Rossum veröffentlicht wurde \cite{wiki-python}. Sie ist für ihre klare Syntax und Lesbarkeit bekannt, was sie zu einer beliebten Wahl für Anfänger und Fortgeschrittene macht. Einige Hauptmerkmale von Python sind dynamische Datentypen, interpretierte Ausführung und die Möglichkeit der objektorientierten Programmierung. Python verfügt außerdem über eine große Standardbibliothek und kann leicht mit C- und C++-Code erweitert werden, was es zu einer beliebten Wahl für eine breite Palette von Anwendungen macht \cite{offical-python}.
\\

\noindent
Die Sprache wird auch von einer großen und aktiven Community, die zur Entwicklung vieler nützlicher Bibliotheken und Werkzeuge für die Sprache beigetragen hat. Diese Bibliotheken stehen für eine Vielzahl von Anwendungen zur Verfügung, z.B. für die Datenanalyse, wissenschaftliche Berechnungen und maschinelles Lernen. Zu den gängigen Bibliotheken und Tools für Python gehören \texttt{NumPy} und \texttt{Pandas} für die Datenanalyse, \texttt{TensorFlow} und \texttt{PyTorch} für maschinelles Lernen, \texttt{Django} und \texttt{Flask} für die Webentwicklung sowie \texttt{Matplotlib} und \texttt{Seaborn} für die Datenvisualisierung \cite{PythonDataScienceHandbook}.
\\

\noindent
Python ist aufgrund seiner Lesbarkeit, Benutzerfreundlichkeit und großartigen Bibliotheksunterstützung eine beliebte Wahl für eine breite Palette von Anwendungen. Seine klare Syntax und Benutzerfreundlichkeit machen es zu einer Sprache für Anfänger und erfahrene Experten, aber auch zu einem leistungsstarken Werkzeug für eine Vielzahl von Anwendungen.\\

\subsubsection{pyBullet}\label{subsubsec:pyBullet}
\texttt{pyBullet} ist eine Python-Bibliothek, die eine einfache Schnittstelle zur Simulation von Robotern und anderen physikalischen Systemen bietet. Sie basiert auf der Bullet Physics Engine, einer Open-Source-Physik-Engine, die für die Simulation von starren Körpern, Flüssigkeiten, Stoffen und anderen physikalischen Phänomenen verwendet wird. \texttt{pyBullet} ermöglicht es, Robotermodelle zu erstellen, ihre Kinematik und Dynamik zu simulieren und ihre Bewegung zu steuern.
\\

\noindent
Für eben diese Berechnung der inversen Kinematik wird auf Grund der einfachen Handhabung und der guten Dokumentation \texttt{pyBullet} verwendet. Die Bibliothek bietet eine Vielzahl von Funktionen und Methoden, die es ermöglichen, die Gelenkwinkel eines Roboters zu berechnen, um eine bestimmte Position und Orientierung des Endeffektors zu erreichen. Die einizige Voraussetzung ist, dass das Modell des Roboters in \texttt{pyBullet} geladen und konfiguriert ist. Dazu wird das Modell in einer \texttt{.urdf}-Datei, siehe \autoref{subsec:DarstellungKinematik}, beschrieben und in \texttt{pyBullet} geladen. Anschließend können die Gelenkwinkel des Roboters berechnet werden, um die gewünschte Position und Orientierung des Endeffektors zu erreichen.\\
\subsection{C\#}
C\# (ausgesprochen "C-Sharp") ist eine moderne, objektorientierte Programmiersprache, die von Microsoft im Jahr 2000 als Teil der .NET-Initiative entwickelt wurde. Die Sprache wurde unter der Leitung von Anders Hejlsberg entwickelt und ist stark von anderen populären Sprachen wie C, C++ und Java inspiriert. C\# ist für seine Vielseitigkeit, Robustheit und Benutzerfreundlichkeit bekannt und wird in einer Vielzahl von Anwendungen eingesetzt, von Desktop- und Web-Anwendungen bis hin zu mobilen Apps und Spielen, insbesondere in der Entwicklung mit der Unity-Engine \cite{hejlsberg2000csharp}.

\subsubsection{Syntax und Grundstruktur}
Die Syntax von C\# ist einfach, klar und gut dokumentiert, was es für Entwickler leicht macht, die Sprache zu erlernen und zu verwenden.

\subsubsection{Objektorientierte Programmierung (OOP)}

C\# unterstützt die vier Hauptprinzipien der objektorientierten Programmierung:
\\

\noindent
1. \textbf{Abstraktion}: Das Verbergen komplexer Implementierungsdetails und lediglich die notwendigen Eigenschaften eines Objekts zu zeigen.
\newline
2. \textbf{Kapselung}: Das Zusammenfassen von Daten und Methoden, die auf diese Daten zugreifen, innerhalb einer Klasse und das Verbergen der Details der Implementierung vor anderen Klassen.
\newline
3. \textbf{Vererbung}: Die Fähigkeit einer Klasse, die Eigenschaften und Methoden einer anderen Klasse zu erben, was Code-Wiederverwendung und Hierarchien ermöglicht und den Code übersichtlicher macht.
\newline
4. \textbf{Polymorphismus}: Die Fähigkeit, eine Methode auf verschiedene Weise zu implementieren oder zu überschreiben, was eine flexible und dynamische Nutzung von Methoden ermöglicht \cite{booch1991oop}.

\subsubsection{Vorteile von C\#}

C\# bietet mehrere Vorteile, die es zu einer guten Wahl für Entwickler machen:
\\

\noindent
- \textbf{Einfach zu erlernen}: Die klare Syntax und die umfangreiche Dokumentation machen C\# zu einer anfängerfreundlichen Sprache.
\newline
- \textbf{Leistungsfähig und flexibel}: C\# ist leistungsfähig genug für komplexe Anwendungen und flexibel genug für schnelle Entwicklung.
\newline
- \textbf{Große Community und Ressourcen}: Die große Entwicklergemeinschaft und die Fülle an Online-Ressourcen, Tutorials und Foren machen es einfach, Unterstützung zu finden und Wissen auszutauschen.
\newline
- \textbf{Integrierte Entwicklungsumgebungen (IDEs)}: Tools wie Visual Studio und Visual Studio Code bieten leistungsstarke Entwicklungsumgebungen mit Debugging- und Code-Analyse-Funktionen.

\section{Kinematische Grundlagen}\label{sec:KinematischeGrundlagen}
Im folgenden werden die verwendeten Kinematischen Grundlagen genauer betrachtet.
\subsection{DH-Parameter}\label{subsec:DHParameter}
Die Denavit-Hartenberg-Parameter (DH-Parameter) sind eine Methode zur Beschreibung der Kinematik eines Roboters. Sie wurden von Jacques Denavit und Richard Hartenberg in den 1950er Jahren entwickelt und sind seitdem zu einem Standardwerkzeug in der Robotik geworden. Die DH-Parameter beschreiben die Beziehung zwischen den Gelenken eines Roboters und den Koordinatensystemen, die sie verbinden. Sie ermöglichen es, die Position und Orientierung eines Endeffektors in Bezug auf die Gelenkwinkel des Roboters zu berechnen.
\\

\noindent
Die DH-Parameter bestehen aus vier Parametern, die für jedes Gelenk des Roboters definiert werden. Diese Parameter sind:
\begin{itemize}
    \item $a_i$ - der Abstand zwischen den Gelenken $i-1$ und $i$ entlang der gemeinsamen Normalen (X-Achse).
    \item $\alpha_i$ - der Winkel zwischen den Gelenken $i-1$ und $i$ entlang der gemeinsamen Normalen (X-Achse).
    \item $d_i$ - der Abstand zwischen den Gelenken $i-1$ und $i$ entlang der gemeinsamen Tangente (Z-Achse).
    \item $\theta_i$ - der Winkel zwischen den Gelenken $i-1$ und $i$ entlang der gemeinsamen Tangente (Z-Achse).
\end{itemize}
\normfig{DH-Parameter-Beispiel}{0.7}{wiki_DH_parameters}
Die DH-Parameter werden in einer Tabelle dargestellt, die die Beziehung zwischen den Gelenken und den Koordinatensystemen beschreibt. Diese Tabelle wird als DH-Parameter-Tabelle bezeichnet und enthält die DH-Parameter für jedes Gelenk des Roboters. Die DH-Parameter-Tabelle wird verwendet, um die Transformationsmatrizen zwischen den Koordinatensystemen zu berechnen, die die Position und Orientierung des Endeffektors beschreiben \cite{msi_robo_vorlesung}.\\
\begin{table}
    \centering
    \begin{tabular}[H]{r|c|c|c|c}
        \textbf{Gelenk} & \textbf{$a_i$} & \textbf{$\alpha_i$} & \textbf{$d_i$} & \textbf{$\theta_i$} \\
        \hline
        1 & $a_1$ & $\alpha_1$ & $d_1$ & $\theta_1$ \\
        2 & $a_2$ & $\alpha_2$ & $d_2$ & $\theta_2$ \\
        3 & $a_3$ & $\alpha_3$ & $d_3$ & $\theta_3$ \\
    \end{tabular}
    \label{tab:DH-Parameter}
    \caption{Eine DH-Parameter-Tabelle}
\end{table}

\subsection{Trajektion}\label{subsec:Trajektion}
Im physikalischen Sinne ist eine Trajektorie die Bahn, die ein Objekt durchläuft, wenn es sich bewegt \cite{wiki-trajektorie}. Dieses Prinzip kann so direkt in der Robotik verwendet werden, denn auch in der Robotik wird darunter die Bewegung eines Roboters von einem Startpunkt zu einem Zielpunkt bezeichnet, also die Berechnung einer Bahn. Die Trajektion kann entweder linear oder gekrümmt sein, je nach den Anforderungen der Anwendung. Die Trajektion wird oft durch eine Trajektorie beschrieben, die die Position und Orientierung des Roboters über die Zeit beschreibt.
\\

\noindent
Die Trajektorie kann durch verschiedene Methoden berechnet werden, darunter geometrische Methoden, numerische Methoden und optimierungsorientierte Methoden. Geometrische Methoden basieren auf der Geometrie des Roboters und verwenden trigonometrische Beziehungen, um die Trajektorie zu berechnen. Numerische Methoden verwenden iterative Verfahren, um die Trajektorie schrittweise zu approximieren. Optimierungsorientierte Methoden formulieren das Problem der Trajektorie als Optimierungsproblem und verwenden Optimierungsalgorithmen, um die Trajektorie zu berechnen.
\\

\noindent
Die wohl einfachsten Trajektorien sind lineare Trajektorien, bei denen der Roboter von einem Startpunkt zu einem Zielpunkt in einer geraden Linie bewegt wird. Diese Trajektorien sind einfach zu berechnen und zu implementieren, aber sie sind oft nicht optimal, da sie nicht die Dynamik des Roboters berücksichtigen. Andere Trajektorien, wie etwa gekrümmte Trajektorien, berücksichtigen die Dynamik des Roboters und sind oft komplexer zu berechnen und zu implementieren, weswegen in diesem Projekt primär die lineare Trajektion verwendet wird.\\
\normfig{Trajektorie}{0.8}{inproceedings}

\subsection{Interpolation}\label{subsec:Interpolation}
Unter Interpolation versteht man in der Robotik die Berechnung von Zwischenwerten zwischen zwei Punkten, um eine kontinuierliche Bewegung des Roboters zu ermöglichen. Die Interpolation wird oft verwendet, um die Gelenkwinkel des Roboters schrittweise zu ändern, um eine Trajektorie zu berechnen.
\\

\noindent
Die Interpolation kann durch verschiedene Methoden berechnet werden, darunter lineare Interpolation, kubische Interpolation und splinebasierte Interpolation.
\begin{itemize}
    \item Lineare Interpolation berechnet die Zwischenwerte linear zwischen den beiden Punkten. Dies resultiert wie in \autoref{img:Lineare-Interpolation} in einer geraden Linie zwischen den beiden Punkten was in den Punkten selbst starke Beschleunigungen und Verzögerungen zur Folge hat.
        \normfig{Lineare-Interpolation}{0.3}{wiki_interpolation_mathematik}
    \item Polynomial Interpolation, oder Interpolation über höhere Polynome, berechnet die Zwischenwerte der Punkte durch eine Funktion \textit{n}-ten Grades. Wie in \autoref{img:Polynomial-Interpolation} gezeigt ermöglicht dies eine deutlöich glattere und kontinuierlichere Interpolation als die lineare Interpolation.
        \normfig{Polynomial-Interpolation}{0.3}{wiki_interpolation_mathematik}
    \item Splinebasierte Interpolation berechnet die Zwischenwerte durch die Verwendung von Splines. In \autoref{img:Spline-Interpolation} ist gezeigt wie eine solche Interpolation auf kubischer Basis aussehen könnte. Gut zu erkennen ist hier, dass diese Art der Interpolation eine glatte und kontinuierliche Kurve.
        \normfig{Spline-Interpolation}{0.3}{wiki_interpolation_mathematik}
\end{itemize}
Welche dieser Arten der Interpolation verwendet wird, hängt im Endeffekt von den Anforderungen der Anwendung ab.\\

\subsection{Inverse Kinematik}\label{subsec:InverseKinematik}
Die inverse Kinematik ist ein mathematisches Problem, bei dem die Gelenkwinkel eines Roboters berechnet werden, um eine bestimmte Position und Orientierung des Endeffektors zu erreichen. Sie ist das Gegenstück zur direkten Kinematik, bei der die Position und Orientierung des Endeffektors aus den Gelenkwinkeln berechnet werden.\\
\normfig{Inverse-Kinematik}{1}{wiki_inverse_kinematics}
\noindent
Das Problem der inversen Kinematik ist in der Regel nicht trivial, da es oft mehrere Lösungen gibt oder die Lösung nicht eindeutig ist. Es gibt verschiedene Methoden zur Lösung des Problems der inversen Kinematik, darunter geometrische Methoden, numerische Methoden und optimierungsorientierte Methoden.
\\

\noindent
Geometrische Methoden basieren auf der Geometrie des Roboters und verwenden trigonometrische Beziehungen, um die Gelenkwinkel zu berechnen. Numerische Methoden verwenden iterative Verfahren, um die Gelenkwinkel schrittweise zu approximieren. Optimierungsorientierte Methoden formulieren das Problem der inversen Kinematik als Optimierungsproblem und verwenden Optimierungsalgorithmen, um die Gelenkwinkel zu berechnen.
\\

\noindent
Die Wahl der Methode hängt von der Komplexität des Roboters, der Genauigkeit der Lösung und den Anforderungen der Anwendung ab. In der Praxis werden oft Kombinationen verschiedener Methoden verwendet, um das Problem der inversen Kinematik zu lösen.\\

\subsection{Darstellung einer Kinematik}\label{subsec:DarstellungKinematik}

\subsubsection{URDF}\label{subsubsec:URDF}
\ac{URDF} ist ein \ac{XML}-Format, das in \ac{ROS} verwendet wird, um die physische Beschreibung und die kinematische Struktur eines Roboters zu definieren. Es enthält Informationen über die Größe, Form, Farbe und Position der verschiedenen Teile des Roboters sowie über die Gelenke, die diese Teile verbinden. Eine \ac{URDF}-Datei besteht aus einer Reihe von Elementen, darunter:
\begin{itemize}
    \item \textbf{Link}: Ein Link repräsentiert eine starre Komponente des Roboters. Jeder Link hat eine Masse und eine Trägheit, die für die physikalische Simulation des Roboters verwendet werden.
    \item \textbf{Joint}: Ein Joint verbindet zwei Links und definiert, wie sie sich relativ zueinander bewegen können. Es gibt verschiedene Arten von Gelenken, darunter feste Gelenke, Drehgelenke und Schiebegelenke.
    \item \textbf{Transmission}: Ein Transmission-Element definiert die mechanische Verbindung zwischen einem Motor und einem Gelenk.
\end{itemize}

\subsubsection{SRDF}\label{subsubsec:SRDF}
\ac{SRDF} ist ein weiteres \ac{XML}-Format, das in \ac{ROS} verwendet wird, um semantische Informationen über einen Roboter zu speichern, die über die physische Beschreibung in der URDF hinausgehen. Es wird hauptsächlich von der MoveIt-Bibliothek verwendet, um Informationen für die Bewegungsplanung zu speichern. Eine solche \ac{SRDF}-Datei enthält folgende Elemente, darunter:
\begin{itemize}
    \item \textbf{Group}: Eine Gruppe ist eine Sammlung von Gelenken und Links, die zusammen bewegt werden können. Gruppen werden oft verwendet, um die Arme, Beine oder andere bewegliche Teile eines Roboters zu repräsentieren.
    \item \textbf{End Effector}: Ein End Effector ist ein spezieller Link, der zum Interagieren mit der Umgebung verwendet wird, zum Beispiel eine Roboterhand oder ein Werkzeug.
    \item \textbf{Collision Matrix}: Die Collision Matrix definiert, welche Paare von Links ignoriert werden sollen, wenn Kollisionen erkannt werden. Dies ist nützlich, um falsche Kollisionen zu vermeiden, die durch die Nähe von Teilen des Roboters entstehen können.
\end{itemize}
Zusammen bieten \ac{URDF} und \ac{SRDF} eine vollständige Beschreibung eines Roboters, die sowohl seine physische Struktur als auch seine semantischen Informationen umfasst. Diese Beschreibungen können dann von verschiedenen \ac{ROS}-Tools und -Bibliotheken verwendet werden, um Aufgaben wie Bewegungsplanung, Kollisionserkennung und Simulation durchzuführen.




\section{Virtual Reality}
Virtual Reality (VR) hat sich in den letzten Jahrzehnten von einem visionären Konzept zu einer greifbaren Technologie entwickelt, die in zahlreichen Bereichen unseres Lebens Anwendung findet. VR bezeichnet computergenerierte, dreidimensionale Umgebungen, die durch spezielle Hardware wie VR-Brillen und Bewegungssensoren eine immersive Erfahrung ermöglichen. Benutzer können in diese virtuellen Welten eintauchen und mit ihnen interagieren, was das Gefühl vermittelt, tatsächlich dort anwesend zu sein.
\\

\noindent
Die rapide Weiterentwicklung von Hardware und Software sowie die steigende Akzeptanz und Integration von VR in verschiedenen Lebensbereichen zeigen, dass diese Technologie das Potenzial hat, unsere Interaktion mit digitalen Inhalten und unsere Wahrnehmung von Realität grundlegend zu verändern. 

\subsection{die Geschichte von VR}
Die Wurzeln der VR-Technologie reichen bis in die 1960er Jahre zurück. Einer der frühesten Vorläufer moderner VR-Systeme war das Sensorama, das 1962 von Morton Heilig entwickelt wurde. Das Sensorama bot multisensorische Erlebnisse und kann als eines der ersten Systeme betrachtet werden, das den Nutzer vollständig in eine künstliche Umgebung eintauchen ließ \cite{heilig1962}. Ein weiterer bedeutender Meilenstein war das "Sword of Damocles", das erste echte VR-Headset, das 1968 von Ivan Sutherland entwickelt wurde. Es war ein unhandliches Gerät, welches an der Decke montiert werden musste, und bot eine rudimentäre Form der virtuellen Realität, wie wir sie heute kennen \cite{sutherland1968}.
\\

\noindent
In den 1980er und 1990er Jahren erlebte VR einen weiteren Aufschwung, insbesondere durch die Arbeit von Jaron Lanier, der den Begriff „Virtual Reality“ populär machte und die Firma VPL Research gründete, die einige der ersten kommerziellen VR-Produkte entwickelte \cite{lanier1992}. Trotz dieser Fortschritte blieb VR lange Zeit eine Nischentechnologie, hauptsächlich aufgrund der hohen Kosten und technischen Einschränkungen.
\\

\noindent
Erst in den 2010er Jahren, mit der Einführung moderner, kostengünstigerer VR-Headsets wie der Oculus Rift, entwickelte sich VR zu einer breiter zugänglichen Technologie. Die Oculus Rift, ursprünglich 2012 auf Kickstarter finanziert, revolutionierte den Markt und führte zu einer neuen Welle von Innovationen in der VR-Technologie \cite{luckey2012}. Kurz darauf folgten andere bedeutende Systeme wie die HTC Vive und PlayStation VR, die die VR-Erfahrung weiter verbesserten und breitere Zielgruppen erreichten.
\\

\noindent
Die heutige VR-Technologie zeichnet sich durch hochauflösende Displays, präzises Tracking und eine Vielzahl von Eingabemethoden aus, die eine immersive und interaktive Erfahrung ermöglichen. Meta Quest 3 (ehemals Oculus Quest 3) ist ein Beispiel für ein modernes, eigenständiges VR-Headset, das keine Verbindung zu einem leistungsstarken PC benötigt und dennoch eine beeindruckende Leistung bietet \cite{meta2023}.

\subsection{Anwendungsgebiete von VR}
Die Anwendungsbereiche von VR sind vielfältig und umfassen nicht nur Unterhaltung und Spiele, sondern auch Bildung, medizinische Therapie, Training und Simulationen, Architektur und Design sowie viele andere Felder. Zum Beispiel wird VR in der Medizin zur Behandlung von Phobien, in der Schmerztherapie und in der Rehabilitation eingesetzt \cite{rizzo2017}. In der Ausbildung ermöglicht VR realitätsnahe Trainingsumgebungen, die sicher und kontrolliert sind, was insbesondere in der Luftfahrt und der Medizin von großem Nutzen ist \cite{huang2018}.


\section{Entwicklung für Virtual Reality}
Die Entwicklungsumgebungen für VR sind Softwareplattformen, welche den Entwicklern die Werkzeuge und Funktionen zur Erstellung von Anwendungen für VR-Brillen bieten. Die zwei bekanntesten und am häufigsten verwendeten sind Unity und Unreal Engine. Diese beiden bieten eine umfassende Unterstützung für die VR-Entwicklung. Sie werden in vielen Anwendungen und Spielen und auch bei industriellen Lösungen verwendet. Im folgenden werden beide Entwicklungsplattformen vorgestellt, in Kapitel 3 wird dann erläutert für welche der beiden Plattformen sich für die Entwicklung des Projekts entschieden wurde.
\subsection{Unity}
Unity ist eine weit verbreitete, benutzerfreundliche Entwicklungsplattform, die sich durch ihre Vielseitigkeit und umfangreiche Toolsets auszeichnet. Unity bietet integrierte Unterstützung für VR und wird häufig, sowohl bei Anfängern als auch bei großen Spieleprojekten, aufgrund seiner Benutzerfreundlichkeit und der großen Community bevorzugt.
\paragraph{Benutzerfreundlichkeit}
Unity hat eine intuitive Benutzeroberfläche, für welche die Plattform auch bekannt ist. Ebenfalls bekannt ist es für die leichte Erlernbarkeit, weshalb es sowohl Einsteigern als auch erfahrenen Entwicklern zusagt \cite{unity2021}. Diese leichte erlernbarkeit wird durch umfangreiche Dokumentation und Tutorials gestützt.

\paragraph{Unterstützte Plattformen} Unity unterstützt eine Vielzahl von VR-Plattformen, darunter Oculus Rift, HTC Vive, Meta Quest, PlayStation VR und verschiedene mobile VR-Headsets wie Google Cardboard und Samsung Gear VR \cite{unity2021}.
\paragraph{Asset Store}
Der Unity Asset Store bietet eine große Auswahl an vorgefertigten Assets, Plugins und Tools, die die Entwicklung von VR-Anwendungen erleichtern und beschleunigen \cite{unityAssetStore2021}.
\paragraph{Scripting}
Unity verwendet C\# als Hauptprogrammiersprache, was Entwicklern ermöglicht, komplexe Interaktionen und Animationen zu erstellen \cite{unity2021}. Dadurch wird eine weitere Hürde genommen, da die Entwickler, in den meisten Fällen, keine neue Programmiersprache erlernen müssen.
\subsection{Unreal Engine}
Unreal Engine wurde von Epic Games entwickelt und ist ebenfalls eine führende Plattform für die VR Entwicklung. Diese Entwicklungsumgebung ist vor allem für ihre leistungsstarke Grafik und Rendering-Fähigkeiten bekannt . Weitere wichtige Punkte der Unreal Engine werden im folgenden benannt.
\paragraph{Grafikqualität} Die Grafikqualität und realistischen visuellen Effekte, welche besonders bei hochwertigen Spielen wichtig sind, sind bei Unreal Engine besonders ausgeprägt \cite{epic2021}
\paragraph{Unterstützte Plattformen} Wie Unity unterstützt auch Unreal Engine eine breite Palette von VR-Plattformen, einschließlich Oculus Rift, Meta Quest, HTC Vive und PlayStation VR \cite{epic2021}.
\paragraph{Open Source}
Ein großer Vorteil der Unreal Engine ist der Open-Source-Charakter, der Entwicklern vollständigen Zugang zum Quellcode der Engine bietet, was tiefergehende Anpassungen und Optimierungen ermöglicht, es für Anfänger aber schwieriger gestalten kann. \cite{epic2021}.

\subsubsection{Visual Scripting in Unreal Engine}
Blueprints Visual Scripting ist ein visuelles Skripting-System in Unreal Engine, das Entwicklern ermöglicht, komplexe Gameplay-Mechaniken, Schnittstellen und Interaktionen ohne das Schreiben von Code zu erstellen. Dieses System bietet eine benutzerfreundliche Möglichkeit, schnell Prototypen zu erstellen und Mechaniken zu implementieren, was es besonders nützlich für Designer und Entwickler ohne tiefgehende Programmierkenntnisse macht.

\paragraph{Hauptmerkmale von Blueprints Visual Scripting}
Im folgenden werden die Hauptmerkmale der Blueprints Visual Programmierung erläutert. 
\paragraph{Visuelle Programmierung}
Blueprints verwenden ein Knoten-basiertes System, bei dem verschiedene Aktionen und Logiken als Knoten dargestellt werden, die durch Verbindungen miteinander verknüpft werden. Dies ermöglicht eine intuitive und visuelle Art der Programmierung, bei der Entwickler die Logik ihres Spiels auf eine leicht verständliche Weise darstellen können \cite{unrealDocs}.

\paragraph{Ereignisgesteuerte Programmierung}
Blueprints basieren auf einem ereignisgesteuerten Modell, bei dem Aktionen als Reaktionen auf Ereignisse ausgeführt werden. Beispiele für solche Ereignisse sind Benutzerinteraktionen, Kollisionen oder Zeitgeber. Dies erlaubt eine dynamische und flexible Gestaltung der Spielmechaniken \cite{unrealEngine}.

\paragraph{Vielseitigkeit}
Blueprints sind extrem vielseitig und können für eine Vielzahl von Aufgaben eingesetzt werden. Dazu gehören:
\begin{itemize}
    \item \textbf{Charaktersteuerung:} Erstellen von Bewegungs- und Animationslogik für Spielfiguren.
    \item \textbf{Spielmechaniken:} Definieren von Regeln und Mechaniken, die das Spielgeschehen bestimmen, wie z.B. Punktesysteme, Level-Fortschritt und Spielerinteraktionen.
    \item \textbf{Benutzeroberfläche (UI):} Erstellen und Verwalten von UI-Elementen wie Menüs, HUDs und Dialogfenstern.
\end{itemize}

\paragraph{Debugging und Optimierung}
Unreal Engine bietet integrierte Tools zum Debuggen von Blueprints. Entwickler können den Ablauf ihres Skripts visualisieren und Schritt für Schritt durchgehen, um Fehler effizient zu identifizieren und zu beheben. Diese Tools sind essenziell, um die Logik zu überprüfen und die Leistung zu optimieren \cite{unrealDebug}.

\paragraph{Erweiterbarkeit}
Obwohl Blueprints eine leistungsstarke Lösung bieten, können sie durch benutzerdefinierte C++-Klassen erweitert werden. Dies bietet Entwicklern die Möglichkeit, komplexe und spezifische Funktionen zu implementieren, die über die Standardfähigkeiten von Blueprints hinausgehen. Diese Integration ermöglicht eine tiefgehende Anpassung und Flexibilität \cite{unrealCplusplus}.

\paragraph{Vorteile und Herausforderungen} 
Im folgenden werden die Vorteile und Herausforderungen von Blueprints noch einmal zusammengefasst.
\paragraph{Vorteile}
\begin{itemize}
    \item \textbf{Einfache Handhabung:} Blueprints ermöglichen eine schnelle und intuitive Entwicklung ohne tiefgehende Programmierkenntnisse.
    \item \textbf{Schnelle Prototypenerstellung:} Ideen können schnell visualisiert und getestet werden.
    \item \textbf{Integrierte Debugging-Tools:} Einfaches Auffinden und Beheben von Fehlern.
    \item \textbf{Erweiterbar mit C++:} Flexibilität und erweiterte Funktionalitäten durch Integration mit C++.
\end{itemize}

\paragraph{Herausforderungen}
\begin{itemize}
    \item \textbf{Komplexität bei großen Projekten:} Bei sehr großen Projekten kann die Verwaltung und Übersichtlichkeit der Blueprints herausfordernd werden.
    \item \textbf{Performance-Überlegungen:} Während Blueprints leistungsfähig sind, kann die Ausführungsgeschwindigkeit bei sehr komplexen Logiken niedriger sein als bei reinem C++-Code.
\end{itemize}
\noindent
Eine sorgfältige Planung und Anwendung von Blueprints Visual Scripting kann jedoch diese Herausforderungen minimieren und die Entwicklung effizienter und effektiver gestalten.

\subsection{OpenXR}
OpenXR ist ein offener Standard für die Entwicklung von \ac{VR}- und \ac{AR}-Anwendungen, der von der Khronos Group entwickelt wurde. Der Standard zielt darauf ab, die Fragmentierung in der VR- und AR-Industrie zu reduzieren und Entwicklern eine einheitliche Plattform für die Entwicklung von Anwendungen zu bieten. OpenXR ermöglicht es Entwicklern, Anwendungen zu erstellen, die auf einer Vielzahl von \ac{VR}- und \ac{AR}-Plattformen laufen, ohne dass sie für jede Plattform spezifischen Code schreiben müssen. Dies erleichtert die Entwicklung und den Einsatz von \ac{VR}- und \ac{AR}-Anwendungen erheblich und trägt zur Interoperabilität und Kompatibilität zwischen verschiedenen Plattformen bei \cite{unityOpenXR2021}.
\\

\noindent
OpenXR wird sowohl von Unity als auch von Unreal Engine unterstützt und kann in den Projekten implementiert werden. 
\section{Unity-ROS TCP Controller}

Der Unity-ROS TCP Controller ist ein leistungsstarkes Tool, das es ermöglicht, Robot Operating System (ROS) mit der Unity-Engine zu verbinden. Diese Integration bietet Entwicklern die Möglichkeit, VR- und AR-Anwendungen zu erstellen, die mit realen Robotern interagieren können, indem sie Daten zwischen ROS und Unity austauschen. Diese Funktionalität ist besonders nützlich in Bereichen wie Robotik, Simulationen und erweiterter Realität, wo die Interaktion zwischen virtuellen und physischen Welten von zentraler Bedeutung ist \cite{ros_tcp_endpoint,unity_ros_tcp_connector}.

\subsection{Grundlagen und Architektur}

Der Unity-ROS TCP Controller funktioniert durch die Verwendung eines TCP-Protokolls zur Kommunikation zwischen ROS und Unity. Dies ermöglicht eine zuverlässige und bidirektionale Datenübertragung, die für Anwendungen erforderlich ist, die auf Echtzeitdaten angewiesen sind. Die grundlegende Architektur besteht aus zwei Hauptkomponenten:

\begin{enumerate}
    \item \textbf{ROS TCP Endpoint}: Dies ist der Server, der auf der ROS-Seite läuft und auf eingehende Verbindungen von Unity wartet. Er empfängt Nachrichten von Unity und sendet Nachrichten an Unity \cite{ros_tcp_endpoint}.
    \item \textbf{Unity TCP Connector}: Dies ist der Client, der in Unity läuft und eine Verbindung zum ROS TCP Endpoint herstellt. Er sendet Nachrichten an ROS und empfängt Nachrichten von ROS \cite{unity_ros_tcp_connector}.
\end{enumerate}

\subsection{Einrichtung und Verwendung}

Die Einrichtung des Unity-ROS TCP Controllers umfasst mehrere Schritte, sowohl auf der ROS- als auch auf der Unity-Seite. Hier ist eine allgemeine Anleitung zur Einrichtung:

\subsubsection{ROS-Seite}

\begin{itemize}
    \item Installiere die erforderlichen ROS-Pakete, z.B. \texttt{ros\_tcp\_endpoint} \cite{ros_tcp_endpoint}.
    \item Starte den ROS TCP Endpoint:
    \begin{verbatim}
roslaunch ros_tcp_endpoint endpoint.launch
    \end{verbatim}
\end{itemize}

\subsubsection{Unity-Seite}

\begin{itemize}
    \item Importiere das ROS-TCP-Connector-Paket in dein Unity-Projekt \cite{unity_ros_tcp_connector}.
    \item Füge das \texttt{RosConnector}-Skript zu einem GameObject in deiner Szene hinzu und konfiguriere die IP-Adresse und den Port des ROS-TCP-Endpunkts.
    \item Erstelle Nachrichten-Typen in Unity, die mit den ROS-Nachrichten übereinstimmen, die du senden und empfangen möchtest.
    \item Verwende das \texttt{RosConnector}-Skript, um Nachrichten an ROS zu senden und Nachrichten von ROS zu empfangen.
\end{itemize}

\subsection{Beispiel für Unity-Skript}

Hier ist ein Beispiel für ein Unity-Skript, das den Unity-ROS TCP Controller verwendet, um Positionsdaten an ROS zu senden:

\begin{verbatim}
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Geometry;

public class PositionPublisher : MonoBehaviour
{
    ROSConnection ros;
    public string topicName = "/unity/position";
    public float publishRate = 0.5f;

    private float timeElapsed;

    void Start()
    {
        ros = ROSConnection.instance;
        ros.RegisterPublisher<PointMsg>(topicName);
    }

    void Update()
    {
        timeElapsed += Time.deltaTime;

        if (timeElapsed > publishRate)
        {
            PointMsg positionMessage = new PointMsg(
                transform.position.x,
                transform.position.y,
                transform.position.z
            );

            ros.Publish(topicName, positionMessage);

            timeElapsed = 0;
        }
    }
}
\end{verbatim}
\noindent
In diesem Beispiel wird die Position eines GameObjects in Unity periodisch an ein ROS-Thema gesendet. Das Skript:

\begin{itemize}
    \item Registriert einen Publisher für das angegebene ROS-Thema.
    \item Sendet die Position des GameObjects als \texttt{PointMsg}-Nachricht an ROS \cite{unity_ros_tcp_connector}.
\end{itemize}

\subsection{Vorteile und Anwendungsbereiche}

Der Unity-ROS TCP Controller bietet zahlreiche Vorteile:

\begin{itemize}
    \item \textbf{Echtzeit-Interaktion}: Ermöglicht die Echtzeit-Interaktion zwischen virtuellen und physischen Robotern.
    \item \textbf{Flexibilität}: Unterstützt verschiedene ROS-Nachrichtentypen und ermöglicht die Anpassung an spezifische Anwendungsanforderungen.
    \item \textbf{Erweiterbarkeit}: Kann in verschiedene VR/AR-Projekte integriert werden, um erweiterte Robotik-Simulationen und Visualisierungen zu erstellen.
\end{itemize}

Anwendungsbereiche umfassen:

\begin{itemize}
    \item \textbf{Robotik-Forschung}: Simulation und Testen von Robotern in virtuellen Umgebungen.
    \item \textbf{Bildung}: Interaktive Lernumgebungen für die Robotik-Ausbildung.
    \item \textbf{Industrie}: Visualisierung und Steuerung von Industrierobotern in einer virtuellen Umgebung.
\end{itemize}

\subsection{Fazit}

Der Unity-ROS TCP Controller ist ein mächtiges Werkzeug, das die Lücke zwischen virtuellen Simulationen in Unity und realen Robotersystemen, die auf ROS basieren, schließt. Durch die Nutzung von TCP für die Kommunikation bietet es eine robuste und flexible Lösung für eine Vielzahl von Anwendungen in der Robotik und darüber hinaus.
\section{Unreal Engine ROS Integration}

\subsection{Einführung}

Die Unreal Engine ROS Integration ermöglicht die Verbindung und Interaktion zwischen dem Robot Operating System (ROS) und der Unreal Engine. Diese Integration bietet ähnliche Funktionen wie der Unity-ROS TCP Controller und ist nützlich für die Erstellung von Simulationen, Visualisierungen und interaktiven Anwendungen, die mit physischen Robotern kommunizieren \cite{ros_integration_github}.

\subsection{Grundlagen und Architektur}

Das ROSIntegration Plugin für die Unreal Engine besteht aus mehreren Komponenten, die zusammenarbeiten, um eine nahtlose Kommunikation zwischen ROS und der Unreal Engine zu gewährleisten. Die grundlegende Architektur umfasst:

\begin{enumerate}
    \item \textbf{ROS Nodes}: Diese werden in ROS definiert und dienen zur Kommunikation und Datenverarbeitung.
    \item \textbf{Unreal Engine ROS Nodes}: Diese Nodes werden in der Unreal Engine erstellt und fungieren als Schnittstelle zu den ROS Nodes.
\end{enumerate}

\subsection{Einrichtung und Verwendung}

Die Einrichtung des ROSIntegration Plugins in der Unreal Engine umfasst mehrere Schritte:

\subsubsection{Installation des Plugins}

\begin{itemize}
    \item Lade das ROSIntegration Plugin von der offiziellen GitHub-Seite herunter: \url{https://github.com/code-iai/ROSIntegration}.
    \item Füge das Plugin zu deinem Unreal Engine Projekt hinzu und aktiviere es in den Projekteinstellungen.
\end{itemize}

\subsubsection{Konfiguration des Plugins}

\begin{itemize}
    \item Konfiguriere die IP-Adresse und den Port des ROS Masters, mit dem die Unreal Engine kommunizieren soll.
    \item Stelle sicher, dass das ROS Master läuft und erreichbar ist.
\end{itemize}

\subsubsection{Erstellen von ROS-Komponenten in Unreal}

\begin{itemize}
    \item Erstelle ROS-spezifische Komponenten wie Publisher und Subscriber in der Unreal Engine, um Daten zu senden und zu empfangen.
\end{itemize}

\subsection{Beispiel für Unreal Engine Skript}

Hier ist ein Beispiel für die Verwendung des ROSIntegration Plugins in der Unreal Engine, um Positionsdaten zu veröffentlichen:

\begin{verbatim}
#include "ROSIntegrationGameMode.h"
#include "ROSIntegration/Public/ROSIntegrationGameInstance.h"
#include "ROSIntegration/Public/Publisher.h"
#include "ROSIntegration/Public/std_msgs/String.h"

void AROSIntegrationGameMode::BeginPlay()
{
    Super::BeginPlay();

    UROSIntegrationGameInstance* ROSInst = 
        Cast<UROSIntegrationGameInstance>(GetGameInstance());
    if (ROSInst)
    {
        ROSInst->Init();

        TSharedPtr<ROSPublisher> Publisher = 
            MakeShareable(new ROSPublisher(ROSInst->ROSIntegrationCore, 
                                           TEXT("/unity/position"), 
                                           TEXT("geometry_msgs/Point")));
        Publisher->Advertise();
        
        // Publish a message
        FROSTime now = ROSInst->ROSIntegrationCore->ROSTimeNow();
        TSharedPtr<ROSMessages::geometry_msgs::Point> PointMessage = 
            MakeShareable(new ROSMessages::geometry_msgs::Point());
        PointMessage->x = GetActorLocation().X;
        PointMessage->y = GetActorLocation().Y;
        PointMessage->z = GetActorLocation().Z;
        Publisher->Publish(PointMessage);
    }
}
\end{verbatim}

In diesem Beispiel wird die Position eines Akteurs (Actors) in der Unreal Engine an ein ROS-Thema gesendet. Das Skript:

\begin{itemize}
    \item Initialisiert das ROSIntegration Plugin.
    \item Erstellt einen Publisher für das angegebene ROS-Thema.
    \item Sendet die Position des Akteurs als \texttt{geometry\_msgs/Point} Nachricht an ROS \cite{ros_integration_github}.
\end{itemize}

\subsection{Vorteile und Anwendungsbereiche}

Die Integration von ROS in die Unreal Engine bietet zahlreiche Vorteile:

\begin{itemize}
    \item \textbf{Echtzeit-Interaktion}: Ermöglicht die Echtzeit-Interaktion zwischen virtuellen und physischen Robotern.
    \item \textbf{Visuelle Genauigkeit}: Die Unreal Engine bietet hochwertige Grafiken und realistische Visualisierungen, die für Simulationen und Präsentationen nützlich sind.
    \item \textbf{Flexibilität}: Unterstützt verschiedene ROS-Nachrichtentypen und ermöglicht die Anpassung an spezifische Anwendungsanforderungen.
\end{itemize}

Anwendungsbereiche umfassen:

\begin{itemize}
    \item \textbf{Robotik-Forschung}: Simulation und Testen von Robotern in virtuellen Umgebungen.
    \item \textbf{Bildung}: Interaktive Lernumgebungen für die Robotik-Ausbildung.
    \item \textbf{Industrie}: Visualisierung und Steuerung von Industrierobotern in einer virtuellen Umgebung.
\end{itemize}

\subsection{Fazit}

Die Unreal Engine ROS Integration ist ein mächtiges Werkzeug, das die Lücke zwischen virtuellen Simulationen in der Unreal Engine und realen Robotersystemen, die auf ROS basieren, schließt. Durch die Nutzung dieses Plugins können Entwickler hochwertige Simulationen und Anwendungen erstellen, die eine nahtlose Integration von ROS-Daten in die Unreal Engine ermöglichen.
